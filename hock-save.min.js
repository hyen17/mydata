(async () => {
  // Utility to inject jsPDF
  const injectJsPDF = async () => {
    if (window.jspdf) {
      alert("jsPDF already loaded.");
      return;
    }
    const script = document.createElement("script");
    script.src = "https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js";
    script.onload = () => alert("jsPDF loaded.");
    script.onerror = () => alert("Failed to load jsPDF. Check console for errors.");
    document.head.appendChild(script);
  };

  const autoSave = async () => {
    const questionContainers = document.querySelectorAll('.watupro-choices-columns.show-question');
    if (!questionContainers.length) {
        alert("No questions found on the page (selector: .watupro-choices-columns.show-question).");
        return;
    }

    const saved = [];
    const elementsToIterate = questionContainers;

    console.log(`Found ${elementsToIterate.length} question blocks to process.`);

    for (let i = 0; i < elementsToIterate.length; i++) {
      const currentBlock = elementsToIterate[i];
      let questionContentEl, choicesContainerEl;

      questionContentEl = currentBlock.querySelector('.show-question-content');
      choicesContainerEl = currentBlock.querySelector('.show-question-choices');

      if (!questionContentEl) {
        console.warn(`Could not find .show-question-content for block ${i + 1}. Skipping. Block:`, currentBlock);
        continue;
      }
      if (!choicesContainerEl) {
        console.warn(`Could not find .show-question-choices for block ${i + 1}. Skipping. Block:`, currentBlock);
        continue;
      }

      // --- Extract and Clean Question Text ---
      let questionHtml = questionContentEl.innerHTML;
      const tempDivQ = document.createElement('div');
      tempDivQ.innerHTML = questionHtml;
      const spanNum = tempDivQ.querySelector('span.watupro_num');
      if (spanNum) {
          spanNum.remove();
      }
      let firstChildNode = tempDivQ.firstChild;
      while(firstChildNode && ( (firstChildNode.nodeType === Node.ELEMENT_NODE && firstChildNode.tagName === 'P' && firstChildNode.innerHTML.trim() === '&nbsp;') || (firstChildNode.nodeType === Node.TEXT_NODE && !firstChildNode.textContent.trim()) || (firstChildNode.nodeType === Node.ELEMENT_NODE && firstChildNode.tagName === 'P' && !firstChildNode.textContent.trim() && !firstChildNode.children.length) )) {
          firstChildNode.remove();
          firstChildNode = tempDivQ.firstChild;
      }
      questionHtml = tempDivQ.innerHTML.trim();

      // --- Extract Choices ---
      const choiceLiElements = Array.from(choicesContainerEl.querySelectorAll('ul > li.answer'));
      const choices = [];
      const validChoiceLetters = ['A', 'B', 'C', 'D'];
      for (const li of choiceLiElements) {
        const answerSpan = li.querySelector('span.answer');
        if (!answerSpan) continue;
        const choiceFullText = answerSpan.textContent.trim();
        let letter = '', text = '';
        const match = choiceFullText.match(/^([A-Z])\.\s*(.*)/s);
        if (match) { [ ,letter, text] = match; }
        else { text = choiceFullText; if (choices.length < validChoiceLetters.length) letter = validChoiceLetters[choices.length];}
        if (choices.length < 4 || validChoiceLetters.includes(letter.toUpperCase())) {
            choices.push({ letter, text, isCorrect: li.classList.contains('correct-answer') });
        }
        if (choices.length >= 4) break;
      }

      // --- Extract All Explanations (Titling based on if it's THE .feedback-correct element) ---
      let allExplanations = [];
      const extractExplanationData = (el, isTheDesignatedCorrectEl = false) => {
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = el.innerHTML; // Work on a copy
          const bTag = tempDiv.querySelector('b');
          let letter = '';
          let type = 'incorrect'; // Default type

          if (bTag) {
              const originalBText = bTag.textContent.trim();
              const matchLetter = originalBText.match(/(?:Correct Answer Explanation for|Incorrect Answer Explanation for|Explanation for) ([A-D]):/i);
              if (matchLetter) {
                  letter = matchLetter[1].toUpperCase();
              }

              if (isTheDesignatedCorrectEl) { // This element has .feedback-correct class
                  bTag.textContent = `Correct Answer Explanation for ${letter || 'N/A'}:`;
                  type = 'correct';
              } else { // This element does NOT have .feedback-correct (or it's a duplicate from spoiler)
                  bTag.textContent = `Explanation for ${letter || 'N/A'}:`;
                  // type remains 'incorrect'
              }
          } else {
            if (isTheDesignatedCorrectEl) type = 'correct';
          }
          
          return { letter, type, html: tempDiv.innerHTML.trim() };
      };
      
      const correctExplanationEl = currentBlock.querySelector('.watupro-choice-feedback.feedback-correct');
      if (correctExplanationEl) {
          const data = extractExplanationData(correctExplanationEl, true);
          allExplanations.push(data);
      }

      const otherFeedbackElements = currentBlock.querySelectorAll(':scope > .watupro-choice-feedback:not(.feedback-correct)');
      otherFeedbackElements.forEach(el => {
          if (el.closest('.su-spoiler-content')) return; 
          const data = extractExplanationData(el, false); 
          allExplanations.push(data);
      });
      
      const spoilerContent = currentBlock.querySelector('.su-spoiler-content');
      if (spoilerContent) {
          const spoilerFeedbacks = spoilerContent.querySelectorAll('.watupro-choice-feedback');
          spoilerFeedbacks.forEach(el => {
              const isSpoilerElMarkedCorrect = el.classList.contains('feedback-correct');
              if (isSpoilerElMarkedCorrect && correctExplanationEl && el === correctExplanationEl) return; 
              const data = extractExplanationData(el, false); 
              allExplanations.push(data);
          });
      }

      const uniqueExplanations = [];
      const seenContentForDedupe = new Set(); 
      allExplanations.sort((a, b) => {
          if (a.type === 'correct' && b.type !== 'correct') return -1;
          if (a.type !== 'correct' && b.type === 'correct') return 1;
          if (a.letter && b.letter) return a.letter.localeCompare(b.letter);
          if (a.letter) return -1; 
          if (b.letter) return 1;
          return 0; 
      });

      for (const expl of allExplanations) {
          if (!seenContentForDedupe.has(expl.html)) {
              uniqueExplanations.push(expl);
              seenContentForDedupe.add(expl.html);
          }
      }
      
      const feedbacksHtml = uniqueExplanations.map(e => e.html);

      let postChoiceHtml = '';
      const choiceUl = choicesContainerEl.querySelector('ul');
      if (choiceUl) {
          let nextSibling = choiceUl.nextElementSibling;
          while (nextSibling) {
              if (nextSibling.tagName === 'P') {
                  postChoiceHtml += nextSibling.outerHTML;
              }
              nextSibling = nextSibling.nextElementSibling;
          }
      }
      saved.push({ questionHtml, choices, feedbacks: feedbacksHtml, postChoiceHtml });
    }
    localStorage.setItem('savedQuestions', JSON.stringify(saved));
    alert(`Saved all ${saved.length} questions to localStorage.`);
  };

  const renderPDFs = async () => {
    if (!window.jspdf || !window.jspdf.jsPDF) {
        alert("jsPDF is not loaded. Please inject jsPDF first.");
        return;
    }
    const { jsPDF } = window.jspdf;
    const data = JSON.parse(localStorage.getItem('savedQuestions') || '[]');
    if (!data.length) return alert("No saved data to print.");

    let topic = 'Topic'; 
    const highchartsLabel = document.querySelector('.highcharts-axis-labels.highcharts-xaxis-labels text');
    if (highchartsLabel && highchartsLabel.textContent.trim()) {
        topic = highchartsLabel.textContent.trim();
        topic = topic.replace(/_/g, ' '); 
    } else if (document.title && document.title.trim() !== "") {
        topic = document.title.trim();
    } else {
        const h1 = document.querySelector('h1');
        if (h1 && h1.innerText.trim() !== "") topic = h1.innerText.trim();
        else {
            const h2 = document.querySelector('h2');
            if (h2 && h2.innerText.trim() !== "") topic = h2.innerText.trim();
        }
    }
    topic = topic.replace(/[^a-z0-9\s,-]/gi, ''); 
    topic = topic.replace(/\s+/g, ' ').trim(); 
    if (!topic || topic === '-' || topic === ',') topic = 'Quiz Export'; 

    const pageWidth = 210, margin = 15;
    const usableWidth = pageWidth - 2 * margin;
    const lineHeight = 5.5; 
    const pageHeight = 297;
    const maxY = pageHeight - margin;

    const toRoman = n => ({ 1: 'I', 2: 'II', 3: 'III', 4: 'IV', 5: 'V' }[n] || n.toString());

    const estimateHtmlHeight = (doc, html, fs = 12, currentUsableWidth = usableWidth, currentFontStyle = 'normal') => {
        // This estimation is now less accurate due to inline flow, but serves as a rough guide
        if (!html || !html.trim()) return 0;
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = html;
        tempDiv.querySelectorAll('script, style').forEach(el => el.remove());
        const textContent = tempDiv.innerText || tempDiv.textContent || "";
        if (!textContent.trim()) return 0;
        
        doc.setFontSize(fs).setFont(undefined, currentFontStyle); 
        const lines = doc.splitTextToSize(textContent, currentUsableWidth);
        doc.setFont(undefined, 'normal'); 
        return lines.length * lineHeight * 1.2; // Add some buffer for inline complexity
    };
    
    const estimateBlockHeight = (doc, questionData, showAnswer) => {
        let height = 0;
        height += 10; 
        height += estimateHtmlHeight(doc, questionData.questionHtml, 12, usableWidth);
        height += lineHeight; 

        questionData.choices.forEach(c => {
            const isCorrect = showAnswer && questionData.choices.find(ch => ch.letter === c.letter)?.isCorrect;
            height += estimateHtmlHeight(doc, `${c.letter}. ${c.text}`, 12, usableWidth, isCorrect ? 'bold' : 'normal');
            height += lineHeight * 0.25; 
        });
        height += lineHeight; 

        if (showAnswer && questionData.feedbacks) {
            questionData.feedbacks.forEach(fbHtml => {
                height += estimateHtmlHeight(doc, fbHtml, 12, usableWidth);
                height += lineHeight * 0.5; 
            });
        }
        if (showAnswer && questionData.postChoiceHtml) {
            height += estimateHtmlHeight(doc, questionData.postChoiceHtml, 10, usableWidth, 'italic'); 
        }
        return height + 20; 
    };

    // --- New Inline Text Processing Functions ---
    const processInlineText = (parentNode, initialStyle = 'normal') => {
        let segments = [];
        const processChildren = (node, currentStyle) => {
            if (node.nodeType === Node.TEXT_NODE) {
                const text = node.textContent.replace(/\s+/g, ' ').trim(); // Normalize whitespace
                if (text) {
                    segments.push({ text: text + " ", style: currentStyle }); // Add space for flow
                }
            } else if (node.nodeType === Node.ELEMENT_NODE) {
                let newStyle = currentStyle;
                const tagName = node.tagName.toUpperCase();
                if (tagName === 'STRONG' || tagName === 'B') newStyle = 'bold';
                else if (tagName === 'EM' || tagName === 'I') newStyle = 'italic';
                // Add other inline tags if needed

                for (const child of Array.from(node.childNodes)) {
                    processChildren(child, newStyle);
                }
            }
        };
        for (const child of Array.from(parentNode.childNodes)) {
            processChildren(child, initialStyle);
        }
        // Trim trailing space from the last segment if any
        if (segments.length > 0) {
            segments[segments.length -1].text = segments[segments.length -1].text.trimEnd();
        }
        return segments;
    };

    const renderInlineText = (doc, textSegments, x, y, maxWidth, currentFontSize) => {
        let currentX = x;
        let currentY = y;

        for (const segment of textSegments) {
            if (!segment.text.trim()) continue; // Skip empty or whitespace-only segments

            doc.setFontSize(currentFontSize).setFont(undefined, segment.style);
            const words = segment.text.split(/(\s+)/); // Split by space, keeping spaces

            for (const word of words) {
                if (!word) continue; // Skip empty strings from split
                const wordWidth = doc.getStringUnitWidth(word) * currentFontSize / doc.internal.scaleFactor;

                if (currentX + wordWidth > x + maxWidth && currentX > x) { // Word doesn't fit and it's not the start of line
                    currentY += lineHeight;
                    currentX = x;
                    if (currentY + lineHeight > maxY + 0.5) {
                        doc.addPage();
                        currentY = margin;
                        currentX = x;
                    }
                }
                // Check again if on a new line, the word itself is too long
                if (wordWidth > maxWidth && word.length > 1) { // Word is longer than the line
                    const splitPoint = Math.floor(word.length * (maxWidth / wordWidth));
                    const part1 = word.substring(0, splitPoint);
                    const part2 = word.substring(splitPoint);
                    
                    doc.text(part1, currentX, currentY);
                    currentY += lineHeight;
                    currentX = x;
                    if (currentY + lineHeight > maxY + 0.5) {
                        doc.addPage(); currentY = margin; currentX = x;
                    }
                    // Recursively handle the rest of the long word (simplified here)
                    // For simplicity, just print the rest on new line or split further if needed
                    // This part needs more robust long-word splitting logic
                    const remainingLines = doc.splitTextToSize(part2, maxWidth);
                    for(let i=0; i < remainingLines.length; i++){
                        doc.text(remainingLines[i], currentX, currentY);
                        if (i < remainingLines.length -1) {
                            currentY += lineHeight;
                            if (currentY + lineHeight > maxY + 0.5) { doc.addPage(); currentY = margin; }
                        }
                    }
                    currentX += doc.getStringUnitWidth(remainingLines[remainingLines.length-1]) * currentFontSize / doc.internal.scaleFactor;

                } else {
                     doc.text(word, currentX, currentY);
                     currentX += wordWidth;
                }
            }
        }
        return currentY + lineHeight; // Return Y for the start of the next block/line
    };


    const renderHTML = (doc, html, startY, initialStyle = 'normal', currentFontSize = 12, currentXIndent = margin) => {
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = html;
      let currentY = startY;

      const processBlockNode = (node, yPos, style, listLevel = 0, listCounter = 1, listType = null, xIndent) => {
        let newY = yPos;
        let nodeStyle = style; 
        let childNodesStyle = style; 
        const effectiveXIndent = xIndent + (listLevel * 6); 

        if (node.nodeType === Node.ELEMENT_NODE) {
          const tagName = node.tagName.toUpperCase();
          
          if (tagName === 'P' || tagName === 'DIV' || (tagName.match(/^H[1-6]$/) && node.childNodes.length > 0 && Array.from(node.childNodes).some(cn => cn.nodeType === Node.TEXT_NODE || ['STRONG', 'EM', 'B', 'I', 'SPAN'].includes(cn.tagName?.toUpperCase())))) {
            // For P, DIV, H tags that likely contain inline text to be flowed
            if (newY !== startY && newY > margin && newY < maxY - lineHeight) newY += lineHeight * 0.5; // Gap before block
            
            if (tagName.match(/^H[1-6]$/)) doc.setFont(undefined, 'bold'); // Style for heading itself
            
            const segments = processInlineText(node, style); // Initial style of the block
            newY = renderInlineText(doc, segments, effectiveXIndent, newY, usableWidth - (effectiveXIndent - margin), currentFontSize);
            
            if (tagName.match(/^H[1-6]$/)) doc.setFont(undefined, style); // Reset style after heading
            if (newY > yPos && newY < maxY - (lineHeight*0.5)) newY += lineHeight * 0.25; // Smaller gap after flowed block
            return newY;

          } else if (tagName === 'STRONG' || tagName === 'B' || tagName.match(/^H[1-4]$/)) childNodesStyle = 'bold';
          else if (tagName === 'EM' || tagName === 'I') childNodesStyle = 'italic';
          else if (node.classList.contains('watupro_num')) return newY;


          if (tagName === 'BR') {
            newY += lineHeight;
            if (newY + lineHeight > maxY + 0.5 && newY > margin + lineHeight/2) { doc.addPage(); newY = margin; }
          } else if (tagName === 'OL' || tagName === 'UL') {
            if (newY !== startY && newY > margin && newY < maxY - lineHeight) newY += lineHeight * 0.5; 
            let itemCounter = 1;
            const currentListType = tagName === 'OL' ? (node.getAttribute('type') || '1') : 'disc';
            for (const li of Array.from(node.children).filter(c => c.tagName === 'LI')) {
              newY = processBlockNode(li, newY, childNodesStyle, listLevel + 1, itemCounter, currentListType, xIndent); 
              itemCounter++;
            }
             if (newY > startY && newY < maxY - lineHeight) newY += lineHeight * 0.5; 
          } else if (tagName === 'LI') {
            if (newY !== startY && newY > margin && newY < maxY - lineHeight) newY += lineHeight * 0.25; 
            let marker;
            if (listType === 'disc') marker = '•';
            else if (listType === '1') marker = `${listCounter}.`;
            else if (listType === 'I') marker = `${toRoman(listCounter)}.`;
            else marker = `${listCounter}.`; 

            if (newY + lineHeight > maxY + 0.5 && newY > margin + lineHeight/2) { doc.addPage(); newY = margin; }
            doc.setFontSize(currentFontSize).setFont(undefined, style); 
            doc.text(marker, effectiveXIndent - 4, newY); 

            // For LI content, use the inline processing
            const segments = processInlineText(node, childNodesStyle); // Pass childNodesStyle for LI content
            newY = renderInlineText(doc, segments, effectiveXIndent + 2, newY, usableWidth - (effectiveXIndent + 2 - margin), currentFontSize);
            // renderInlineText returns Y for the start of the next line/block
            
          } else if (tagName === 'TABLE') { 
            if (newY !== startY && newY > margin && newY < maxY - lineHeight) newY += lineHeight * 0.5; 
            const rows = Array.from(node.querySelectorAll('tbody > tr, thead > tr, tr'));
            for (const row of rows) {
                const cells = Array.from(row.querySelectorAll('td, th'));
                if (cells.length === 0) continue;
                doc.setFontSize(currentFontSize).setFont(undefined, style);
                if (cells.length >= 1) {
                    const firstCellText = cells[0].innerText.trim();
                    const romanMatch = firstCellText.match(/^([IVXLCDM]+)\.$/i);
                    if (romanMatch) { 
                        const romanNumeral = romanMatch[0];
                        let mainTextContent = "";
                        if (cells.length >= 3 && cells[1].innerText.trim() === "") { 
                            mainTextContent = cells[2].innerText.trim();
                        } else if (cells.length >= 2) { 
                             mainTextContent = cells[1].innerText.trim(); 
                             if (cells.length >=3 && !mainTextContent && cells[2].innerText.trim()) mainTextContent = cells[2].innerText.trim(); 
                        }
                        if (!mainTextContent && firstCellText.length > romanNumeral.length) {
                            mainTextContent = firstCellText.substring(romanNumeral.length).trim();
                        }
                        const combinedRowText = romanNumeral + "  " + mainTextContent;
                        const lines = doc.splitTextToSize(combinedRowText, usableWidth - (effectiveXIndent-margin));
                        for(const line of lines){
                            if (newY + lineHeight > maxY + 0.5 && newY > margin + lineHeight/2) { doc.addPage(); newY = margin;}
                            doc.text(line, effectiveXIndent, newY);
                            newY += lineHeight;
                        }
                    } else { 
                        const combinedRowText = cells.map(cell => cell.innerText.trim()).filter(text => text).join("   ");
                        if (combinedRowText) {
                            const lines = doc.splitTextToSize(combinedRowText, usableWidth - (effectiveXIndent - margin));
                            for (const line of lines) {
                                if (newY + lineHeight > maxY + 0.5 && newY > margin + lineHeight/2) { doc.addPage(); newY = margin;}
                                doc.text(line, effectiveXIndent, newY);
                                newY += lineHeight;
                            }
                        } else if (cells.length > 0) { newY += lineHeight * 0.5;}
                    }
                }
                 if (rows.indexOf(row) < rows.length -1 && newY < maxY - lineHeight*0.1) newY += lineHeight * 0.1;
            }
            if (newY > startY && newY < maxY - lineHeight) newY += lineHeight * 0.5; 
          } else { // For other elements not handled by inline processing, or simple wrappers
            for (const child of Array.from(node.childNodes)) {
              newY = processBlockNode(child, newY, childNodesStyle, listLevel, listCounter, listType, xIndent);
            }
          }
        } else if (node.nodeType === Node.TEXT_NODE && node.textContent.trim() !== "") {
            // This case should ideally be caught by parent P/DIV using processInlineText
            // But as a fallback for loose text nodes:
            doc.setFontSize(currentFontSize).setFont(undefined, style);
            const lines = doc.splitTextToSize(node.textContent.replace(/\s+/g, ' ').trim(), usableWidth - (xIndent - margin));
            for (const line of lines) {
                if (newY + lineHeight > maxY + 0.5 && newY > margin + lineHeight/2) { doc.addPage(); newY = margin; }
                doc.text(line.trim(), xIndent, newY);
                newY += lineHeight;
            }
        }
        return newY;
      };

      for (const child of Array.from(tempDiv.childNodes)) {
        currentY = processBlockNode(child, currentY, initialStyle, 0, 1, null, currentXIndent);
      }
      return currentY;
    };

    const renderQuestionBlock = (doc, q, qIndex, totalQuestions, showAnswer, startY) => {
      let y = startY;
      
      doc.setFontSize(14).setFont(undefined, 'bold');
      doc.text(`Question ${qIndex + 1} of ${totalQuestions}`, margin, y);
      y += 5;

      doc.setDrawColor(0); doc.setLineWidth(0.2);
      doc.line(margin, y, pageWidth - margin, y);
      y += 6;

      doc.setFontSize(12).setFont(undefined, 'normal');
      y = renderHTML(doc, q.questionHtml, y, 'normal', 12, margin);
      if (y < maxY - lineHeight) y += lineHeight * 0.5; 

      const choicesToRender = q.choices.filter(c => ['A', 'B', 'C', 'D'].includes(c.letter?.toUpperCase()));
      for (const choice of choicesToRender) {
        const choiceText = `${choice.letter || ''}. ${choice.text}`;
        const isCorrectChoice = showAnswer && choice.isCorrect;
        
        // For choices, direct rendering is simpler and usually doesn't have complex inline styles
        doc.setFontSize(12).setFont(undefined, isCorrectChoice ? 'bold' : 'normal'); 
        const choiceLines = doc.splitTextToSize(choiceText, usableWidth);
        
        let choiceY = y;
        for (const line of choiceLines) {
            if (choiceY + lineHeight > maxY + 0.5 && choiceY > margin + lineHeight/2) {
                 doc.addPage(); choiceY = margin;
                 doc.setFontSize(10).setFont(undefined, 'italic');
                 doc.text(`Q${qIndex + 1} (choices cont.)`, margin, choiceY);
                 choiceY += lineHeight + 2;
            }
            doc.setFontSize(12).setFont(undefined, isCorrectChoice ? 'bold' : 'normal');
            doc.text(line, margin, choiceY);
            choiceY += lineHeight;
        }
        y = choiceY;
        if (y < maxY - lineHeight * 0.25) y += lineHeight * 0.25; 
      }

      if (showAnswer && q.feedbacks?.length) {
        if (y < maxY - lineHeight * 0.5) y += lineHeight * 0.5; 
        for (const fb of q.feedbacks) {
          y = renderHTML(doc, fb, y, 'normal', 12, margin); // Explanations can use the inline renderer
          if (y < maxY - lineHeight * 0.25) y += lineHeight * 0.25; 
        }
      }
      
      if (showAnswer && q.postChoiceHtml && q.postChoiceHtml.trim() !== '') {
          if (y < maxY - lineHeight * 0.5) y += lineHeight * 0.5; 
          y = renderHTML(doc, q.postChoiceHtml, y, 'italic', 10, margin); 
      }
      return y; 
    };

    const docQ = new jsPDF(), docA = new jsPDF();
    let yQ = margin; let yA = margin;
    const interQuestionSpacing = lineHeight * 1.5; 

    data.forEach((q, i) => {
      const estHeightQ = estimateBlockHeight(docQ, q, false);
      if (i > 0 && (yQ + estHeightQ > maxY)) {
        docQ.addPage(); yQ = margin;
      } else if (i > 0) {
        yQ += interQuestionSpacing;
        if (yQ + estHeightQ > maxY) { 
            docQ.addPage(); yQ = margin;
        }
      }
      yQ = renderQuestionBlock(docQ, q, i, data.length, false, yQ);

      if (i > 0) { 
        docA.addPage(); 
      }
      yA = margin; 
      yA = renderQuestionBlock(docA, q, i, data.length, true, yA);
    });

    docQ.save(`${topic} - Questions.pdf`);
    docA.save(`${topic} - Answers.pdf`);
    alert("PDFs generated.");
  };

  // UI setup
  if (!document.getElementById('pdfToolsUI')) {
    const panel = document.createElement('div');
    panel.id = 'pdfToolsUI';
    panel.style = 'position:fixed;top:20px;right:20px;z-index:9999;padding:15px;background:white;border:1px solid #ccc;box-shadow:0 0 10px rgba(0,0,0,0.2);font-family:Arial,sans-serif;font-size:14px;border-radius:5px;';
    panel.innerHTML = `
      <h3 style="margin-top:0;margin-bottom:10px;font-size:16px;border-bottom:1px solid #eee;padding-bottom:5px;">PDF Tool</h3>
      <button id="btnInject" style="background-color:#007bff;color:white;border:none;padding:8px 12px;margin-bottom:10px;width:100%;border-radius:3px;cursor:pointer;">Inject jsPDF</button>
      <button id="btnSave" style="background-color:#28a745;color:white;border:none;padding:8px 12px;margin-bottom:10px;width:100%;border-radius:3px;cursor:pointer;">Extract All Questions</button>
      <button id="btnRender" style="background-color:#17a2b8;color:white;border:none;padding:8px 12px;width:100%;border-radius:3px;cursor:pointer;">Generate PDFs</button>
      <p style="font-size:11px;color:#666;margin-top:10px;">Pastikan jsPDF di-inject sebelum generate. Semua data pertanyaan akan disimpan di localStorage browser.</p>
    `;
    document.body.appendChild(panel);
    document.getElementById('btnInject').onclick = injectJsPDF;
    document.getElementById('btnSave').onclick = autoSave;
    document.getElementById('btnRender').onclick = renderPDFs;
  } else {
    alert("PDF tool UI already added.");
  }
})();
