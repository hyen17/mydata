(async () => {
  // Utility to inject jsPDF
  const injectJsPDF = async () => { 
    if (window.jspdf) {
      alert("jsPDF already loaded.");
      return;
    }
    const script = document.createElement("script");
    script.src = "https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js";
    script.onload = () => alert("jsPDF loaded.");
    script.onerror = () => alert("Failed to load jsPDF. Check console for errors.");
    document.head.appendChild(script);
    console.log("injectJsPDF function called and jsPDF script injection attempted.");
  };

  // Helper function to remove ZeroWidthSpace characters
  const cleanZeroWidthSpaces = (text) => {
    if (typeof text === 'string') {
      // \u200B is the Unicode for Zero Width Space.
      // The HTML entity &ZeroWidthSpace; should be parsed into this character by the browser.
      return text.replace(/\u200B/g, ''); 
    }
    return text;
  };

  const autoSave = () => { 
    const questionContainers = document.querySelectorAll('.watupro-choices-columns.show-question');
    if (!questionContainers.length) {
        alert("No questions found on the page (selector: .watupro-choices-columns.show-question).");
        return;
    }

    const saved = [];
    const elementsToIterate = questionContainers;
    console.log(`Found ${elementsToIterate.length} question blocks to process.`);

    for (let i = 0; i < elementsToIterate.length; i++) {
      const currentBlock = elementsToIterate[i];
      let questionContentEl, choicesContainerEl;

      questionContentEl = currentBlock.querySelector('.show-question-content');
      choicesContainerEl = currentBlock.querySelector('.show-question-choices');

      if (!questionContentEl) {
        console.warn(`Could not find .show-question-content for block ${i + 1}. Skipping. Block:`, currentBlock);
        continue;
      }
      if (!choicesContainerEl) {
        console.warn(`Could not find .show-question-choices for block ${i + 1}. Skipping. Block:`, currentBlock);
        continue;
      }

      const tempDivQ = document.createElement('div');
      tempDivQ.innerHTML = questionContentEl.innerHTML; 
      
      const imgTags = Array.from(tempDivQ.querySelectorAll('img')); 
      imgTags.forEach(imgNode => {
          const currentSrc = imgNode.getAttribute('src');
          let newSrc = currentSrc;
          if (currentSrc) {
              if (currentSrc.startsWith('/admin/')) { 
                  newSrc = `https://www.hockinternational.com${currentSrc.startsWith('//') ? currentSrc.substring(1) : currentSrc}`;
              } else if (currentSrc.startsWith('//')) { 
                  newSrc = `https:${currentSrc}`;
              } else if (currentSrc.startsWith('/') && !currentSrc.startsWith('//')) { 
                  newSrc = `${document.location.origin}${currentSrc}`;
              } else if (!currentSrc.startsWith('http://') && !currentSrc.startsWith('https://') && !currentSrc.startsWith('data:')) {
                  try {
                      newSrc = new URL(currentSrc, document.location.href).href;
                  } catch (e) {
                      console.warn(`[autoSave] Could not resolve relative image URL: ${currentSrc}`, e);
                      newSrc = currentSrc; 
                  }
              }
          }

          const altText = imgNode.getAttribute('alt') || '';
          const htmlWidth = imgNode.getAttribute('width') || '';
          const htmlHeight = imgNode.getAttribute('height') || '';

          const placeholderDiv = document.createElement('div');
          placeholderDiv.setAttribute('data-is-image-placeholder', 'true');
          placeholderDiv.setAttribute('data-img-src', newSrc || 'No source');
          placeholderDiv.setAttribute('data-img-alt', altText);
          placeholderDiv.setAttribute('data-img-html-width', htmlWidth);
          placeholderDiv.setAttribute('data-img-html-height', htmlHeight);
          placeholderDiv.innerHTML = ``; 
          
          if (imgNode.parentNode) {
            imgNode.parentNode.replaceChild(placeholderDiv, imgNode);
          } else {
            console.warn("[autoSave] Image tag did not have a parent node for replacement.");
          }
      });
      
      const spanNum = tempDivQ.querySelector('span.watupro_num');
      if (spanNum) { spanNum.remove(); }
      let firstChildNode = tempDivQ.firstChild;
      while(firstChildNode && ( (firstChildNode.nodeType === Node.ELEMENT_NODE && firstChildNode.tagName === 'P' && firstChildNode.innerHTML.trim() === '&nbsp;') || (firstChildNode.nodeType === Node.TEXT_NODE && !firstChildNode.textContent.trim()) || (firstChildNode.nodeType === Node.ELEMENT_NODE && firstChildNode.tagName === 'P' && !firstChildNode.textContent.trim() && !firstChildNode.children.length) )) {
          firstChildNode.remove();
          firstChildNode = tempDivQ.firstChild;
      }
      let questionHtml = tempDivQ.innerHTML.trim();
      questionHtml = cleanZeroWidthSpaces(questionHtml); // Clean HTML string

      const choiceLiElements = Array.from(choicesContainerEl.querySelectorAll('ul > li.answer'));
      const choices = [];
      const validChoiceLetters = ['A', 'B', 'C', 'D'];
      for (const li of choiceLiElements) {
        const answerSpan = li.querySelector('span.answer');
        if (!answerSpan) continue;
        let choiceFullText = answerSpan.textContent.trim();
        // choiceFullText = cleanZeroWidthSpaces(choiceFullText); // Cleaned when creating choice object's text property

        let letter = '', text = '';
        const match = choiceFullText.match(/^([A-Z])\.\s*(.*)/s);
        if (match) { [ ,letter, text] = match; }
        else { text = choiceFullText; if (choices.length < validChoiceLetters.length) letter = validChoiceLetters[choices.length];}
        
        if (choices.length < 4 || validChoiceLetters.includes(letter.toUpperCase())) {
            choices.push({ letter, text: cleanZeroWidthSpaces(text), isCorrect: li.classList.contains('correct-answer') });
        }
        if (choices.length >= 4) break;
      }

      let allExplanations = [];
      const extractExplanationData = (el, isTheDesignatedCorrectEl = false) => {
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = el.innerHTML; 
          const bTag = tempDiv.querySelector('b');
          let letter = '';
          let type = 'incorrect'; 
          if (bTag) {
              let originalBText = bTag.textContent.trim();
              originalBText = cleanZeroWidthSpaces(originalBText); 
              const matchLetter = originalBText.match(/(?:Correct Answer Explanation for|Incorrect Answer Explanation for|Explanation for) ([A-D]):/i);
              if (matchLetter) letter = matchLetter[1].toUpperCase();
              if (isTheDesignatedCorrectEl) { 
                  bTag.textContent = `Correct Answer Explanation for ${letter || 'N/A'}:`; type = 'correct';
              } else { 
                  bTag.textContent = `Explanation for ${letter || 'N/A'}:`;
              }
          } else { if (isTheDesignatedCorrectEl) type = 'correct'; }
          let explanationHtmlContent = tempDiv.innerHTML.trim();
          explanationHtmlContent = cleanZeroWidthSpaces(explanationHtmlContent); 
          return { letter, type, html: explanationHtmlContent };
      };
      const correctExplanationEl = currentBlock.querySelector('.watupro-choice-feedback.feedback-correct');
      if (correctExplanationEl) allExplanations.push(extractExplanationData(correctExplanationEl, true));
      currentBlock.querySelectorAll(':scope > .watupro-choice-feedback:not(.feedback-correct)').forEach(el => {
          if (!el.closest('.su-spoiler-content')) allExplanations.push(extractExplanationData(el, false));
      });
      const spoilerContent = currentBlock.querySelector('.su-spoiler-content');
      if (spoilerContent) {
          spoilerContent.querySelectorAll('.watupro-choice-feedback').forEach(el => {
              if (!(el.classList.contains('feedback-correct') && correctExplanationEl && el === correctExplanationEl)) {
                allExplanations.push(extractExplanationData(el, false));
              }
          });
      }
      const uniqueExplanations = [];
      const seenContentForDedupe = new Set(); 
      allExplanations.sort((a, b) => {
          if (a.type === 'correct' && b.type !== 'correct') return -1;
          if (a.type !== 'correct' && b.type === 'correct') return 1;
          if (a.letter && b.letter) return a.letter.localeCompare(b.letter);
          if (a.letter) return -1; if (b.letter) return 1; return 0; 
      });
      for (const expl of allExplanations) {
          if (!seenContentForDedupe.has(expl.html)) {
              uniqueExplanations.push(expl); seenContentForDedupe.add(expl.html);
          }
      }
      const feedbacksHtml = uniqueExplanations.map(e => e.html); 
      
      let postChoiceHtmlAccumulator = '';
      const choiceUl = choicesContainerEl.querySelector('ul');
      if (choiceUl) {
          let nextSibling = choiceUl.nextElementSibling;
          while (nextSibling) {
              if (nextSibling.tagName === 'P') postChoiceHtmlAccumulator += nextSibling.outerHTML;
              nextSibling = nextSibling.nextElementSibling;
          }
      }
      const postChoiceHtml = cleanZeroWidthSpaces(postChoiceHtmlAccumulator); 

      saved.push({ questionHtml, choices, feedbacks: feedbacksHtml, postChoiceHtml });
    }
    localStorage.setItem('savedQuestions', JSON.stringify(saved));
    alert(`Saved all ${saved.length} questions to localStorage.`);
  };

  const renderPDFs = () => { 
    if (!window.jspdf || !window.jspdf.jsPDF) {
        alert("jsPDF is not loaded. Please inject jsPDF first.");
        return;
    }
    const { jsPDF } = window.jspdf;
    const data = JSON.parse(localStorage.getItem('savedQuestions') || '[]');
    if (!data.length) return alert("No saved data to print.");

    let topic = 'Topic'; 
    const highchartsLabel = document.querySelector('.highcharts-axis-labels.highcharts-xaxis-labels text');
    if (highchartsLabel && highchartsLabel.textContent.trim()) {
        topic = highchartsLabel.textContent.trim(); topic = topic.replace(/_/g, ' '); 
    } else if (document.title && document.title.trim() !== "") {
        topic = document.title.trim();
    } else {
        const h1 = document.querySelector('h1');
        if (h1 && h1.innerText.trim() !== "") topic = h1.innerText.trim();
        else {
            const h2 = document.querySelector('h2');
            if (h2 && h2.innerText.trim() !== "") topic = h2.innerText.trim();
        }
    }
    topic = topic.replace(/[^a-z0-9\s,-]/gi, '').replace(/\s+/g, ' ').trim(); 
    if (!topic || topic === '-' || topic === ',') topic = 'Quiz Export'; 

    const pageWidth = 210, margin = 15;
    const usableWidth = pageWidth - 2 * margin;
    const lineHeight = 5.5; 
    const pageHeight = 297;
    const maxY = pageHeight - margin;
    const PX_TO_MM_SCALE = 25.4 / 96; 

    const toRoman = n => ({ 1: 'I', 2: 'II', 3: 'III', 4: 'IV', 5: 'V' }[n] || n.toString());

    const estimateHtmlHeight = (doc, html, fs = 12, currentUsableWidth = usableWidth, currentFontStyle = 'normal') => {
        if (!html || !html.trim()) return 0;
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = cleanZeroWidthSpaces(html); 
        let textHeight = 0;
        
        const textOnlyDiv = tempDiv.cloneNode(true);
        textOnlyDiv.querySelectorAll('div[data-is-image-placeholder="true"]').forEach(ph => ph.remove());
        
        const textContent = textOnlyDiv.innerText || textOnlyDiv.textContent || "";
        if (textContent.trim()) {
            doc.setFontSize(fs).setFont(undefined, currentFontStyle); 
            const lines = doc.splitTextToSize(textContent, currentUsableWidth);
            textHeight = lines.length * lineHeight;
            doc.setFont(undefined, 'normal'); 
        }

        let imageReservedHeight = 0;
        tempDiv.querySelectorAll('div[data-is-image-placeholder="true"]').forEach(phNode => {
            textHeight += lineHeight; 
            const htmlHeightStr = phNode.getAttribute('data-img-html-height');
            if (htmlHeightStr && !isNaN(parseFloat(htmlHeightStr))) {
                imageReservedHeight += parseFloat(htmlHeightStr) * PX_TO_MM_SCALE;
            } else {
                imageReservedHeight += lineHeight * 5; 
            }
        });
        return textHeight + imageReservedHeight;
    };
    
    const estimateBlockHeight = (doc, questionData, showAnswer) => {
        let height = 0; height += 10; 
        height += estimateHtmlHeight(doc, questionData.questionHtml, 12, usableWidth); 
        height += lineHeight; 
        questionData.choices.forEach(c => {
            const isCorrect = showAnswer && questionData.choices.find(ch => ch.letter === c.letter)?.isCorrect;
            height += estimateHtmlHeight(doc, `${c.letter}. ${c.text}`, 12, usableWidth, isCorrect ? 'bold' : 'normal');
            height += lineHeight * 0.25; 
        });
        height += lineHeight; 
        if (showAnswer && questionData.feedbacks) {
            questionData.feedbacks.forEach(fbHtml => {
                height += estimateHtmlHeight(doc, fbHtml, 12, usableWidth); 
                height += lineHeight * 0.5; 
            });
        }
        if (showAnswer && questionData.postChoiceHtml) {
            height += estimateHtmlHeight(doc, questionData.postChoiceHtml, 10, usableWidth, 'italic'); 
        }
        return height + 20; 
    };

    const processInlineText = (parentNode, initialStyle = 'normal') => {
        let segments = [];
        const processChildren = (node, currentStyle) => {
            if (node.nodeType === Node.TEXT_NODE) {
                let text = node.textContent; 
                text = cleanZeroWidthSpaces(text); 
                if (text.length > 0) segments.push({ text: text, style: currentStyle }); 
            } else if (node.nodeType === Node.ELEMENT_NODE) {
                let newStyle = currentStyle;
                const tagName = node.tagName.toUpperCase();
                if (tagName === 'STRONG' || tagName === 'B') newStyle = 'bold';
                else if (tagName === 'EM' || tagName === 'I') newStyle = 'italic';
                if (tagName !== 'BR' && !node.hasAttribute('data-is-image-placeholder')) { 
                    for (const child of Array.from(node.childNodes)) processChildren(child, newStyle);
                }
            }
        };
        for (const child of Array.from(parentNode.childNodes)) processChildren(child, initialStyle);
        return segments;
    };

    const renderInlineText = (doc, textSegments, x, y, maxWidth, currentFontSize) => { 
        let currentX = x;
        let currentY = y;
        for (const segment of textSegments) {
            let segmentText = segment.text;
            // segmentText = cleanZeroWidthSpaces(segmentText); // Already cleaned by processInlineText
            if (!segmentText.trim() && segmentText !== " ") continue; 

            doc.setFontSize(currentFontSize).setFont(undefined, segment.style);
            const normalizedText = segmentText.replace(/\s+/g, ' '); 
            const words = normalizedText.split(/(\s)/); 
            for (const word of words) {
                if (!word) continue; 
                const wordWidth = doc.getStringUnitWidth(word) * currentFontSize / doc.internal.scaleFactor;
                if (currentX + wordWidth > x + maxWidth && currentX > x && word.trim() !== "") { 
                    currentY += lineHeight; currentX = x;
                    if (currentY + lineHeight > maxY + 0.5) { doc.addPage(); currentY = margin; currentX = x; }
                }
                if (word.trim() !== "" || (word === " " && currentX > x)) { 
                     doc.text(word, currentX, currentY);
                }
                currentX += wordWidth;
            }
        }
        return currentY; 
    };

    const renderHTML = (doc, html, startY, initialStyle = 'normal', currentFontSize = 12, currentXIndent = margin) => {
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = cleanZeroWidthSpaces(html); 
      let currentY = startY;

      const processBlockNode = (node, yPos, style, listLevel = 0, listCounter = 1, listType = null, xIndent) => { 
        let newY = yPos;
        let nodeStyle = style; 
        let childNodesStyle = style; 
        const effectiveXIndent = xIndent + (listLevel * 6); 

        if (node.nodeType === Node.ELEMENT_NODE) {
          const tagName = node.tagName.toUpperCase();
          
          if (node.hasAttribute('data-is-image-placeholder')) {
            if (newY !== startY && newY > margin && newY < maxY - lineHeight) newY += lineHeight * 0.5;
            
            const imgSrc = cleanZeroWidthSpaces(node.getAttribute('data-img-src'));
            const altText = cleanZeroWidthSpaces(node.getAttribute('data-img-alt') || 'Image');
            const htmlWidthStr = node.getAttribute('data-img-html-width');
            const htmlHeightStr = node.getAttribute('data-img-html-height');

            let placeholderText = `[Gambar: ${altText} | URL: ${imgSrc}`;
            if (htmlWidthStr || htmlHeightStr) { 
                placeholderText += ` | Dimensi HTML: ${htmlWidthStr || 'auto'}x${htmlHeightStr || 'auto'}`;
            }
            placeholderText += "]";
            
            doc.setFontSize(currentFontSize - 2).setFont(undefined, 'italic'); 
            const lines = doc.splitTextToSize(placeholderText, usableWidth - (effectiveXIndent - margin));
            for (const line of lines) {
                if (newY + lineHeight > maxY + 0.5 && newY > margin + lineHeight/2) { doc.addPage(); newY = margin; }
                doc.text(line, effectiveXIndent, newY);
                newY += lineHeight;
            }
            doc.setFontSize(currentFontSize).setFont(undefined, style); 

            if (htmlHeightStr && !isNaN(parseFloat(htmlHeightStr))) {
                const htmlHeightPx = parseFloat(htmlHeightStr);
                const pdfReservedHeightMm = htmlHeightPx * PX_TO_MM_SCALE;
                if (newY + pdfReservedHeightMm > maxY && newY > margin) { 
                    doc.addPage(); newY = margin;
                    doc.setFontSize(currentFontSize - 2).setFont(undefined, 'italic');
                    const linesOnNewPage = doc.splitTextToSize(placeholderText, usableWidth - (effectiveXIndent - margin));
                     for (const line of linesOnNewPage) { 
                         if (newY + lineHeight > maxY + 0.5 && newY > margin + lineHeight/2) { doc.addPage(); newY = margin; }
                          doc.text(line, effectiveXIndent, newY);
                          newY += lineHeight;
                     }
                    doc.setFontSize(currentFontSize).setFont(undefined, style);
                }
                newY += pdfReservedHeightMm; 
            } else {
                newY += lineHeight * 5; 
            }
            if (newY > yPos && newY < maxY - (lineHeight*0.5)) newY += lineHeight * 0.25;
            return newY;

          } else if (tagName === 'P' || tagName === 'DIV' || (tagName.match(/^H[1-6]$/))) {
            if (newY !== startY && newY > margin && newY < maxY - lineHeight) newY += lineHeight * 0.5; 
            if (tagName.match(/^H[1-6]$/)) doc.setFont(undefined, 'bold'); 
            
            const segments = processInlineText(node, style); 
            newY = renderInlineText(doc, segments, effectiveXIndent, newY, usableWidth - (effectiveXIndent - margin), currentFontSize);
            newY += lineHeight; 
            
            if (tagName.match(/^H[1-6]$/)) doc.setFont(undefined, style); 
            if (newY > yPos && newY < maxY - (lineHeight*0.5)) newY += lineHeight * 0.25; 
            return newY;

          } else if (tagName === 'STRONG' || tagName === 'B' || tagName.match(/^H[1-4]$/)) childNodesStyle = 'bold';
          else if (tagName === 'EM' || tagName === 'I') childNodesStyle = 'italic';
          else if (node.classList.contains('watupro_num')) return newY;


          if (tagName === 'BR') {
            newY += lineHeight;
            if (newY + lineHeight > maxY + 0.5 && newY > margin + lineHeight/2) { doc.addPage(); newY = margin; }
          } else if (tagName === 'OL' || tagName === 'UL') {
            if (newY !== startY && newY > margin && newY < maxY - lineHeight) newY += lineHeight * 0.5; 
            let itemCounter = 1;
            const currentListType = tagName === 'OL' ? (node.getAttribute('type') || '1') : 'disc';
            for (const li of Array.from(node.children).filter(c => c.tagName === 'LI')) {
              newY = processBlockNode(li, newY, childNodesStyle, listLevel + 1, itemCounter, currentListType, xIndent); 
              itemCounter++;
            }
             if (newY > startY && newY < maxY - lineHeight) newY += lineHeight * 0.5; 
          } else if (tagName === 'LI') {
            if (newY !== startY && newY > margin && newY < maxY - lineHeight) newY += lineHeight * 0.25; 
            let marker;
            if (listType === 'disc') marker = 'â€¢';
            else if (listType === '1') marker = `${listCounter}.`;
            else if (listType === 'I') marker = `${toRoman(listCounter)}.`;
            else marker = `${listCounter}.`; 

            if (newY + lineHeight > maxY + 0.5 && newY > margin + lineHeight/2) { doc.addPage(); newY = margin; }
            doc.setFontSize(currentFontSize).setFont(undefined, style); 
            doc.text(marker, effectiveXIndent - 4, newY); 

            const segments = processInlineText(node, childNodesStyle); 
            newY = renderInlineText(doc, segments, effectiveXIndent + 2, newY, usableWidth - (effectiveXIndent + 2 - margin), currentFontSize);
            newY += lineHeight; 
            
          } else if (tagName === 'TABLE') { 
            if (newY !== startY && newY > margin && newY < maxY - lineHeight) newY += lineHeight * 0.5; 
            const rows = Array.from(node.querySelectorAll('tbody > tr, tr')); 
            let maxCols = 0;
            rows.forEach(r => {
                let currentColCount = 0;
                Array.from(r.cells).forEach(cell => { currentColCount += parseInt(cell.getAttribute('colspan')) || 1; });
                if (currentColCount > maxCols) maxCols = currentColCount;
            });
            const colWidth = (usableWidth - (effectiveXIndent-margin)) / Math.max(1, maxCols);

            for (const row of rows) {
                const cells = Array.from(row.cells);
                if (cells.length === 0) continue;
                let currentCellX = effectiveXIndent;
                let yForRowCells = newY;
                let maxHeightInThisPdfRow = 0;
                for (const cell of cells) {
                    const cellColspan = parseInt(cell.getAttribute('colspan')) || 1;
                    let cellTextContent = cell.innerText.trim(); 
                    cellTextContent = cleanZeroWidthSpaces(cellTextContent).replace(/\s+/g, ' '); 

                    const cellHtmlAlign = cell.getAttribute('align') || 'left';
                    const actualCellWidth = colWidth * cellColspan;
                    let cellStyle = style;
                    if (cell.querySelector('strong') || cell.tagName === 'TH') cellStyle = 'bold';
                    doc.setFontSize(currentFontSize).setFont(undefined, cellStyle);
                    const lines = doc.splitTextToSize(cellTextContent, actualCellWidth - 2); 
                    let yForCurrentCellInLines = yForRowCells;
                    for (const line of lines) {
                        if (yForCurrentCellInLines + lineHeight > maxY + 0.5 && yForCurrentCellInLines > margin + lineHeight/2) {
                            doc.addPage(); yForCurrentCellInLines = margin; yForRowCells = margin; 
                        }
                        const textWidth = doc.getStringUnitWidth(line) * currentFontSize / doc.internal.scaleFactor;
                        let xPos;
                        if (cellHtmlAlign === 'right') xPos = currentCellX + actualCellWidth - textWidth - 1;
                        else if (cellHtmlAlign === 'center') xPos = currentCellX + (actualCellWidth - textWidth) / 2;
                        else xPos = currentCellX + 1;
                        doc.text(line, xPos, yForCurrentCellInLines);
                        yForCurrentCellInLines += lineHeight;
                    }
                    maxHeightInThisPdfRow = Math.max(maxHeightInThisPdfRow, yForCurrentCellInLines - yForRowCells);
                    currentCellX += actualCellWidth;
                    doc.setFont(undefined, style); 
                }
                newY = yForRowCells + maxHeightInThisPdfRow; 
                 if (rows.indexOf(row) < rows.length -1 && newY < maxY - lineHeight*0.1) newY += lineHeight * 0.1;
            }
            if (newY > startY && newY < maxY - lineHeight) newY += lineHeight * 0.5; 
          } else { 
            for (const child of Array.from(node.childNodes)) {
              newY = processBlockNode(child, newY, childNodesStyle, listLevel, listCounter, listType, xIndent); 
            }
          }
        } else if (node.nodeType === Node.TEXT_NODE) {
            let textContent = node.textContent;
            textContent = cleanZeroWidthSpaces(textContent); 
            if (textContent.trim() !== "") {
                doc.setFontSize(currentFontSize).setFont(undefined, style);
                const lines = doc.splitTextToSize(textContent.replace(/\s+/g, ' ').trim(), usableWidth - (xIndent - margin));
                for (const line of lines) {
                    if (newY + lineHeight > maxY + 0.5 && newY > margin + lineHeight/2) { doc.addPage(); newY = margin; }
                    doc.text(line.trim(), xIndent, newY);
                    newY += lineHeight;
                }
            }
        }
        return newY;
      };

      for (const child of Array.from(tempDiv.childNodes)) {
        currentY = processBlockNode(child, currentY, initialStyle, 0, 1, null, currentXIndent); 
      }
      return currentY;
    };

    const renderQuestionBlock = (doc, q, qIndex, totalQuestions, showAnswer, startY) => { 
      let y = startY;
      doc.setFontSize(14).setFont(undefined, 'bold');
      doc.text(`Question ${qIndex + 1} of ${totalQuestions}`, margin, y);
      y += 5;
      doc.setDrawColor(0); doc.setLineWidth(0.2);
      doc.line(margin, y, pageWidth - margin, y);
      y += 6;
      doc.setFontSize(12).setFont(undefined, 'normal');
      y = renderHTML(doc, q.questionHtml, y, 'normal', 12, margin); 
      if (y < maxY - lineHeight) y += lineHeight * 0.5; 
      const choicesToRender = q.choices.filter(c => ['A', 'B', 'C', 'D'].includes(c.letter?.toUpperCase()));
      for (const choice of choicesToRender) {
        const choiceText = `${choice.letter || ''}. ${cleanZeroWidthSpaces(choice.text)}`; 
        const isCorrectChoice = showAnswer && choice.isCorrect;
        doc.setFontSize(12).setFont(undefined, isCorrectChoice ? 'bold' : 'normal'); 
        const choiceLines = doc.splitTextToSize(choiceText, usableWidth);
        let choiceY = y;
        for (const line of choiceLines) {
            if (choiceY + lineHeight > maxY + 0.5 && choiceY > margin + lineHeight/2) {
                 doc.addPage(); choiceY = margin;
                 doc.setFontSize(10).setFont(undefined, 'italic');
                 doc.text(`Q${qIndex + 1} (choices cont.)`, margin, choiceY);
                 choiceY += lineHeight + 2;
            }
            doc.setFontSize(12).setFont(undefined, isCorrectChoice ? 'bold' : 'normal');
            doc.text(line, margin, choiceY);
            choiceY += lineHeight;
        }
        y = choiceY;
        if (y < maxY - lineHeight * 0.25) y += lineHeight * 0.25; 
      }
      if (showAnswer && q.feedbacks?.length) {
        if (y < maxY - lineHeight * 0.5) y += lineHeight * 0.5; 
        for (const fb of q.feedbacks) {
          y = renderHTML(doc, fb, y, 'normal', 12, margin); 
          if (y < maxY - lineHeight * 0.25) y += lineHeight * 0.25; 
        }
      }
      if (showAnswer && q.postChoiceHtml && q.postChoiceHtml.trim() !== '') {
          if (y < maxY - lineHeight * 0.5) y += lineHeight * 0.5; 
          y = renderHTML(doc, q.postChoiceHtml, y, 'italic', 10, margin); 
      }
      return y; 
    };

    const docQ = new jsPDF(), docA = new jsPDF();
    let yQ = margin; let yA = margin;
    const interQuestionSpacing = lineHeight * 1.5; 
    data.forEach((q, i) => { 
        const estHeightQ = estimateBlockHeight(docQ, q, false);
        if (i > 0 && (yQ + estHeightQ > maxY)) {
            docQ.addPage(); yQ = margin;
        } else if (i > 0) {
            yQ += interQuestionSpacing;
            if (yQ + estHeightQ > maxY) { 
                docQ.addPage(); yQ = margin;
            }
        }
        yQ = renderQuestionBlock(docQ, q, i, data.length, false, yQ);
        if (i > 0) { 
            docA.addPage(); 
        }
        yA = margin; 
        yA = renderQuestionBlock(docA, q, i, data.length, true, yA);
    });
    docQ.save(`${topic} - Questions.pdf`);
    docA.save(`${topic} - Answers.pdf`);
    alert("PDFs generated.");
  };

  // UI setup
  if (!document.getElementById('pdfToolsUI')) {
    const panel = document.createElement('div');
    panel.id = 'pdfToolsUI';
    panel.style = 'position:fixed;top:20px;right:20px;z-index:999999;padding:15px;background:white;border:1px solid #ccc;box-shadow:0 0 10px rgba(0,0,0,0.2);font-family:Arial,sans-serif;font-size:14px;border-radius:5px;';
    panel.innerHTML = `
      <h3 style="margin-top:0;margin-bottom:10px;font-size:16px;border-bottom:1px solid #eee;padding-bottom:5px;">PDF Tool</h3>
      <button id="btnInject" style="background-color:#007bff;color:white;border:none;padding:8px 12px;margin-bottom:10px;width:100%;border-radius:3px;cursor:pointer;">Inject jsPDF</button>
      <button id="btnSave" style="background-color:#28a745;color:white;border:none;padding:8px 12px;margin-bottom:10px;width:100%;border-radius:3px;cursor:pointer;">Extract All Questions</button>
      <button id="btnRender" style="background-color:#17a2b8;color:white;border:none;padding:8px 12px;width:100%;border-radius:3px;cursor:pointer;">Generate PDFs</button>
      <p style="font-size:11px;color:#666;margin-top:10px;">Pastikan jsPDF di-inject sebelum generate. Semua data pertanyaan akan disimpan di localStorage browser.</p>
    `;
    document.body.appendChild(panel);
    console.log('Panel UI PDF Tool telah ditambahkan ke body.');
    
    const btnInject = document.getElementById('btnInject');
    const btnSave = document.getElementById('btnSave');
    const btnRender = document.getElementById('btnRender');

    if (btnInject) btnInject.onclick = injectJsPDF; else console.error("Button btnInject tidak ditemukan.");
    if (btnSave) btnSave.onclick = autoSave; else console.error("Button btnSave tidak ditemukan.");
    if (btnRender) btnRender.onclick = renderPDFs; else console.error("Button btnRender tidak ditemukan.");
    
  } else {
    alert("PDF tool UI sudah ada.");
    console.log("Panel UI pdfToolsUI sudah ada.");
  }
})();

