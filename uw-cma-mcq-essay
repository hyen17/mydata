(() => { 
  // ---------- Config / Utils ----------
  const letters = (n) => String.fromCharCode(64 + n); // 1->A

  // ---------- Sanitizers ----------
  function removeChoicePercentSpans(html) {
    if (!html) return html;
    return html
      .replace(/<span[^>]*class=["']?choice-percent["']?[^>]*>.*?<\/span>/gi, '')
      .replace(/\(\s*\d{1,3}%\s*\)/g, '');
  }

  function removeVideoAndEmptyP(html) {
    if (!html) return html;
    let h = String(html);

    h = h.replace(/<a\b[^>]*>\s*Video\s*<\/a>/gi, '');

    h = h.replace(/<p\b[^>]*>[\s\S]*?<\/p>/gi, (m) => {
      if (/<img\b/i.test(m)) return m;
      if (/^<p[^>]*>\s*(?:&nbsp;|\s|<br\s*\/?>)*<\/p>$/i.test(m)) return '';
      return m;
    });

    h = h.replace(/>\s+</g, '><');
    return h;
  }

  // NEW: remove common essay prompt text like "Type your response here..."
  function removeEssayPrompt(html) {
    if (!html) return html;
    // remove variations of "Type your response here" case-insensitive, with optional dots/colons/whitespace
    return String(html).replace(/type\s+your\s+response\s+here\b[.\s:]*/gi, '');
  }

  function sanitizeContent(html) {
    if (!html) return '';
    let s = String(html);
    s = removeChoicePercentSpans(s);
    s = removeVideoAndEmptyP(s);
    s = removeEssayPrompt(s); // remove essay prompt globally
    return s.trim();
  }

  function addTdSpacing(html) {
    if (!html) return html;
    return html.replace(/<\/td>/gi, '&nbsp;&nbsp;</td>');
  }

  // ---------- UI ----------
  const panel = document.createElement('div');
  panel.style.cssText = `
    position:fixed; right:18px; bottom:18px; z-index:2147483647;
    background:#1f2937; color:#fff; padding:14px; width:380px;
    border-radius:10px; font-family:Arial, Helvetica, sans-serif;
    box-shadow:0 8px 30px rgba(0,0,0,0.4);
  `;

  panel.innerHTML = `
    <div style="font-weight:700; font-size:15px; margin-bottom:8px;">JSON → HTML Generator</div>
    <div style="font-size:13px; margin-bottom:8px;">Upload file JSON. Script akan membuka Questions & Answers di tab baru.</div>

    <input id="fileInput" type="file" accept=".json,.txt,application/json" multiple style="width:100%; margin-bottom:8px;">

    <div style="margin-bottom:6px;">Output mode:</div>
    <label style="display:block; margin-bottom:6px;"><input type="radio" name="outmode" value="separate" checked> Separate (each file → own output)</label>
    <label style="display:block; margin-bottom:10px;"><input type="radio" name="outmode" value="join"> Join (merge all files)</label>

    <div style="margin-bottom:6px;">Page-break mode:</div>
    <label style="display:block;"><input type="radio" name="pb" value="normal" checked> HTML Normal</label>
    <label style="display:block;"><input type="radio" name="pb" value="smart"> HTML Smart</label>
    <label style="display:block; margin-bottom:8px;"><input type="radio" name="pb" value="each"> HTML Page-break per Question</label>

    <label style="display:block; margin-bottom:10px;"><input id="pdfChk" type="checkbox"> Generate PDF (answers)</label>

    <button id="genBtn" style="
      width:100%; padding:10px; background:#10b981; color:#fff; border:none;
      border-radius:6px; font-weight:700; cursor:pointer;
    ">Generate HTML</button>

    <label style="display:block; margin-top:10px;"><input id="autoDl" type="checkbox"> Auto Download (default: No)</label>

    <div id="statusArea" style="margin-top:10px; font-size:13px; color:#d1d5db;"></div>
  `;

  document.body.appendChild(panel);

  const fileInput = panel.querySelector('#fileInput');
  const genBtn = panel.querySelector('#genBtn');
  const statusArea = panel.querySelector('#statusArea');
  const autoDlChk = panel.querySelector('#autoDl');

  const setStatus = (t) => { statusArea.innerText = t; console.log('[gen]', t); };

  // ---------- CSS ----------
  function cssFor(mode) {
    let extra = '';
    if (mode === 'smart') extra = `.q-block{page-break-inside:avoid;}`;
    if (mode === 'each') extra = `.q-block{page-break-before:always;} .q-block:first-child{page-break-before:avoid;}`;

    return `
      body{font-family:Inter, Arial, Helvetica, sans-serif; padding:28px; color:#111; line-height:1.45}
      .q-block{margin-bottom:22px}
      .reading-block{margin-bottom:22px; page-break-before:always;}
      .reading-title{font-size:20px; font-weight:700; margin-bottom:10px;}
      .reading-text{margin-bottom:12px;}

      .q-header{font-weight:700; font-size:18px; margin-bottom:8px}
      .q-text{margin-bottom:10px}

      ol.choices{list-style:none; padding-left:0; margin:0}
      ol.choices li{
        margin:0 !important; padding:6px 4px !important;
        line-height:1.25; display:flex; align-items:flex-start; gap:8px;
      }
      .letter{
        font-weight:700;
        margin-right:4px;
        flex:0 0 auto;
        white-space:nowrap;
      }
      .choice-content{
        flex:1 1 auto;
        min-width:0;
      }

      .correct{font-weight:700; background:#e6f9ea; border:1px solid #2e7d32}
      .tick{color:#2e7d32; font-weight:700; margin-left:8px; font-size:16px}

      table.table-default-style{
        border-collapse: collapse !important; font-size:1em; margin-top:10px; max-width:900px;
      }
      table.table-default-style td, table.table-default-style th {
        border:1px solid black; padding:5px !important; vertical-align:top !important;
      }
      table.table-default-style p{ padding:0 !important; margin:0 !important; }
      table.table-default-style ul, table.table-default-style ol{ padding-left:20px !important; margin:0 !important; }

      .answer-header{ margin:8px 0 12px 36px; }

      .explain-box{ background:#f3f4f6; padding:12px; border-radius:6px; margin-top:10px; }
      .explain-box p{ margin:8px 0 !important; padding:0 !important; }

      img{max-width:100%; height:auto; display:block}

      hr{border:none; border-top:1px solid #e5e7eb; margin:20px 0}

      ${extra}
    `;
  }

  // ---------- JSON parsing ----------
  function parseJsonContent(text) {
    try { return JSON.parse(text); }
    catch {
      const m = text.match(/(\[.*\]|\{[\s\S]*\})/);
      if (!m) throw new Error('Cannot parse JSON');
      return JSON.parse(m[1]);
    }
  }

  function normalizeQuestions(obj) {
    if (!obj) return [];
    if (Array.isArray(obj)) return obj;
    if (obj.questionList) return obj.questionList;
    if (obj.test && obj.test.questionList) return obj.test.questionList;
    if (obj.questions) return obj.questions;
    return [obj];
  }

  const choiceNumberToLetter = (num) => {
    const n = parseInt(num);
    if (!isNaN(n)) return letters(n);
    return 'A';
  };

  // =====================================================================
  // ESSAY + MCQ BUILDER
  // =====================================================================
  function buildBodies(questions, mode, abstracts, isEssay) {
    if (!isEssay) {
      // -----------------------
      // MCQ (as original)
      // -----------------------
      let qBody = '';
      let aBody = '';

      for (let i = 0; i < questions.length; i++) {
        const q = questions[i];
        const seq = (i + 1);

        let qText = sanitizeContent(q.questionText || '');
        let explanation = sanitizeContent(q.explanationText || '');
        let answerHeader = q.answerHeader ? sanitizeContent(addTdSpacing(q.answerHeader)) : null;

        const arr = q.answerChoiceList || q.answerChoice || [];

        let correctLetter = null;
        if (q.correctAnswer != null) {
          const n = parseInt(q.correctAnswer);
          if (!isNaN(n)) correctLetter = letters(n);
          else if (/^[A-Z]$/i.test(String(q.correctAnswer).trim())) correctLetter = String(q.correctAnswer).trim().toUpperCase();
        }

        const normalized = arr.map((ch, idx) => {
          let html = sanitizeContent(ch.choice || '');
          html = addTdSpacing(html);
          html = html.replace(/^\s*[A-Z]\.\s*/i, '');
          if (/^\s*<table/i.test(html) && !/table-default-style/.test(html)) {
            html = html.replace(/<table([^>]*)>/i, '<table class="table-default-style"$1>');
          }
          const letter = ch.choiceNumber ? choiceNumberToLetter(ch.choiceNumber) : letters(idx + 1);
          const isCorrect = correctLetter ? (letter === correctLetter) : !!(ch.isCorrect || ch.correctTaken === true);
          return { letter, html, isCorrect };
        });

        qBody += `<div class="q-block">
          <div class="q-header">Question ${seq} of ${questions.length}</div>
          <div class="q-text">${qText}</div>
          ${answerHeader ? `<div class="answer-header">${answerHeader}</div>` : ''}
          <ol class="choices">`;

        normalized.forEach(c => {
          qBody += `<li><span class="letter">${c.letter}.</span><span class="choice-content">${c.html}</span></li>`;
        });

        qBody += `</ol></div><hr/>`;

        aBody += `<div class="q-block">
          <div class="q-header">Question ${seq} of ${questions.length}</div>
          <div class="q-text">${qText}</div>
          ${answerHeader ? `<div class="answer-header">${answerHeader}</div>` : ''}
          <ol class="choices">`;

        normalized.forEach(c => {
          aBody += `<li class="${c.isCorrect ? 'correct' : ''}">
            <span class="letter">${c.letter}.</span>
            <span class="choice-content">${c.html}${c.isCorrect ? ' <span class="tick">&#10004;</span>' : ''}</span>
          </li>`;
        });

        aBody += `</ol>
          <div class="explain-box"><strong>Explanation:</strong><br>${explanation || '(No explanation)'}</div>
        </div><hr/>`;
      }

      return { qBody, aBody };
    }

    // ------------------------------------------
    // ESSAY MODE (WC)
    // ------------------------------------------
    const groups = [];
    const groupMap = new Map();
    for (const q of questions) {
      const aid = q.abstractId ?? q.abstract?.id ?? null;
      const key = String(aid);
      if (!groupMap.has(key)) {
        groupMap.set(key, []);
        groups.push({ abstractId: aid, questions: groupMap.get(key) });
      }
      groupMap.get(key).push(q);
    }

    const total = questions.length;
    let readingIndex = 0;
    let globalCounter = 0;

    let qBody = '';
    let aBody = '';

    for (const grp of groups) {
      readingIndex++;

      const abs = abstracts ? abstracts[String(grp.abstractId)] : null;
      const absHtml = abs ? sanitizeContent(abs.text || abs.content || '') : '';
      const absTitle = abs ? sanitizeContent(abs.title || 'Reading') : 'Reading';

      // reading block then hr
      qBody += `
        <div class="reading-block">
          <div class="reading-title">${absTitle}</div>
          <div class="reading-text">${absHtml}</div>
        </div>
        <hr/>
      `;

      aBody += `
        <div class="reading-block">
          <div class="reading-title">${absTitle}</div>
          <div class="reading-text">${absHtml}</div>
        </div>
        <hr/>
      `;

      let innerIdx = 0;

      for (const q of grp.questions) {
        globalCounter++;
        innerIdx++;

        const seq = `${readingIndex}.${innerIdx}`;

        // ensure we remove essay prompt text from question/explanation as well
        const qText = sanitizeContent((q.questionText || q.question || '').replace ? (q.questionText || q.question || '') : String(q.questionText || q.question || ''));
        const explanation = sanitizeContent((q.explanationText || q.explanation || '').replace ? (q.explanationText || q.explanation || '') : String(q.explanationText || q.explanation || ''));

        // QUESTIONS: only reading + question (no choices)
        qBody += `
          <div class="q-block">
            <div class="q-header">Question ${seq} of ${total}</div>
            <div class="q-text">${qText}</div>
          </div>
          <hr/>
        `;

        // ANSWERS: reading + question + explanation
        aBody += `
          <div class="q-block">
            <div class="q-header">Question ${seq} of ${total}</div>
            <div class="q-text">${qText}</div>
            <div class="explain-box"><strong>Explanation:</strong><br>${explanation || '(No explanation)'}</div>
          </div>
          <hr/>
        `;
      }
    }

    return { qBody, aBody };
  }

  // =====================================================================
  // BASE64 IMAGE CONVERTER
  // =====================================================================
  async function convertImagesToBase64(htmlString) {
    const div = document.createElement("div");
    div.innerHTML = htmlString;
    const imgs = div.querySelectorAll("img");
    const failed = [];

    async function imgToBase64(url) {
      try {
        const res = await fetch(url, { mode: "cors" });
        const blob = await res.blob();
        return await new Promise(resolve => {
          const reader = new FileReader();
          reader.onloadend = () => resolve(reader.result);
          reader.readAsDataURL(blob);
        });
      } catch (e) {
        failed.push(url);
        return null;
      }
    }

    for (const img of imgs) {
      const url = img.getAttribute("src");
      if (!url) continue;
      const base64 = await imgToBase64(url);
      if (base64) img.setAttribute("src", base64);
    }

    return {
      html: div.innerHTML,
      failed
    };
  }

  // =====================================================================
  // MULTIPLE FILE COLLECTOR
  // =====================================================================
  async function collectQuestionsFromFiles(fileList) {
    const all = [];
    const abstracts = {}; // collect abstracts across files
    let isEssayFlag = false;

    for (let i = 0; i < fileList.length; i++) {
      const f = fileList[i];
      try {
        const txt = await f.text();
        let parsed;
        try { parsed = parseJsonContent(txt); }
        catch (e) {
          alert('JSON Error in file: ' + f.name + ' — ' + e.message);
          continue;
        }

        // collect abstracts if present
        if (parsed.abstractList && Array.isArray(parsed.abstractList)) {
          for (const a of parsed.abstractList) {
            if (a && (a.id != null)) abstracts[String(a.id)] = a;
          }
        }
        if (parsed.abstracts && Array.isArray(parsed.abstracts)) {
          for (const a of parsed.abstracts) {
            if (a && (a.id != null)) abstracts[String(a.id)] = a;
          }
        }
        if (parsed.abstractMap && typeof parsed.abstractMap === 'object') {
          for (const k in parsed.abstractMap) {
            if (parsed.abstractMap[k]) abstracts[String(k)] = parsed.abstractMap[k];
          }
        }

        const fileTestType = parsed.testTypeName || parsed.testType || (parsed.test && parsed.test.testTypeName) || null;
        if (fileTestType === 'WC') isEssayFlag = true;

        const qs = normalizeQuestions(parsed);
        if (qs && qs.length) {
          for (const q of qs) {
            if (fileTestType) q._testTypeName = fileTestType;
            all.push(q);
          }
        }
      } catch (e) {
        alert('Gagal membaca file: ' + f.name);
      }
    }

    all.sort((a, b) => {
      const sa = (a && (a.sequenceId ?? a.questionIndex ?? 0)) || 0;
      const sb = (b && (b.sequenceId ?? b.questionIndex ?? 0)) || 0;
      return sa - sb;
    });

    return { questions: all, abstracts, isEssayFlag };
  }

  // ---------- Helpers ----------
  function getBaseName(filename) {
    if (!filename) return 'file';
    const name = filename.split('/').pop().split('\\').pop();
    const dot = name.lastIndexOf('.');
    return dot === -1 ? name : name.slice(0, dot);
  }

  function downloadBlob(blob, filename) {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      URL.revokeObjectURL(a.href);
      a.remove();
    }, 1500);
  }

  // =====================================================================
  // GENERATE
  // =====================================================================
  async function handleFile(fileOrFiles, outMode, wantPdf) {
    setStatus('Membaca file...');
    const autoDownload = !!autoDlChk.checked;

    let files = Array.from(fileOrFiles || []);

    const doJoin = (outMode === 'join') || (files.length === 1);

    if (doJoin) {
      setStatus('Menggabungkan file (join mode)...');
      const { questions, abstracts, isEssayFlag } = await collectQuestionsFromFiles(files);
      if (!questions.length) return alert('Tidak ada soal.');

      const isEssay = isEssayFlag || questions.some(q => q._testTypeName === 'WC');

      const mode = panel.querySelector("input[name='pb']:checked").value;

      const { qBody, aBody } = buildBodies(questions, mode, abstracts, isEssay);
      const css = cssFor(mode);

      setStatus('Mengonversi gambar ke base64...');
      const convQ = await convertImagesToBase64(qBody);
      const convA = await convertImagesToBase64(aBody);

      const htmlQ = wrapFullHtml('Questions', css, convQ.html);
      const htmlA = wrapFullHtml('Answers', css, convA.html);

      // Always open tabs (both modes open tabs). If autoDownload, also download.
      window.open(URL.createObjectURL(new Blob([htmlQ], { type: 'text/html' })), '_blank');
      const winA = window.open(URL.createObjectURL(new Blob([htmlA], { type: 'text/html' })), '_blank');

      if (autoDownload) {
        downloadBlob(new Blob([htmlQ], { type:'text/html'}), 'Questions.html');
        downloadBlob(new Blob([htmlA], { type:'text/html'}), 'Answers.html');
      }

      if (wantPdf && winA) setTimeout(()=>winA.print(), 800);

      setStatus('Selesai (join).');
      return;
    }

    // SEPARATE MODE
    setStatus('Memproses file secara terpisah...');

    for (let fi = 0; fi < files.length; fi++) {
      const f = files[fi];
      setStatus(`Membaca ${f.name} ...`);
      let parsed;
      try {
        const text = await f.text();
        parsed = parseJsonContent(text);
      } catch (e) {
        alert('JSON Error: ' + f.name);
        continue;
      }

      const questions = normalizeQuestions(parsed);
      if (!questions.length) continue;

      const isEssay = (parsed.testTypeName === "WC") || questions.some(q => q._testTypeName === 'WC');

      // collect abstracts for this file if any
      const absMap = {};
      if (parsed.abstractList && Array.isArray(parsed.abstractList)) {
        parsed.abstractList.forEach(a => { if (a && a.id != null) absMap[String(a.id)] = a; });
      }
      if (parsed.abstracts && Array.isArray(parsed.abstracts)) {
        parsed.abstracts.forEach(a => { if (a && a.id != null) absMap[String(a.id)] = a; });
      }
      if (parsed.abstractMap && typeof parsed.abstractMap === 'object') {
        for (const k in parsed.abstractMap) absMap[String(k)] = parsed.abstractMap[k];
      }

      const mode = panel.querySelector("input[name='pb']:checked").value;

      const { qBody, aBody } = buildBodies(questions, mode, absMap, isEssay);
      const css = cssFor(mode);

      setStatus(`Mengonversi gambar di ${f.name} ...`);
      const convQ = await convertImagesToBase64(qBody);
      const convA = await convertImagesToBase64(aBody);

      const htmlQ = wrapFullHtml('Questions', css, convQ.html);
      const htmlA = wrapFullHtml('Answers', css, convA.html);

      const urlQ = URL.createObjectURL(new Blob([htmlQ], { type: 'text/html' }));
      window.open(urlQ, '_blank');
      const winA = window.open(URL.createObjectURL(new Blob([htmlA], { type: 'text/html' })), '_blank');

      const base = getBaseName(f.name);

      if (autoDownload) {
        downloadBlob(new Blob([htmlQ], {type: 'text/html'}), `${base} - Questions.html`);
        downloadBlob(new Blob([htmlA], {type: 'text/html'}), `${base} - Answers.html`);
      }

      if (wantPdf && winA) setTimeout(()=>winA.print(), 800);
    }

    setStatus('Selesai (separate).');
  }

  function wrapFullHtml(title, css, body) {
    return `<!doctype html><html><head><meta charset="utf-8">
    <title>${title}</title><style>${css}</style></head><body>${body}</body></html>`;
  }

  // ---------- Events ----------
  genBtn.addEventListener('click', () => {
    const files = fileInput.files;
    if (!files || files.length === 0) return alert('Upload JSON dulu.');

    const outMode = panel.querySelector("input[name='outmode']:checked").value;
    const wantPdf = panel.querySelector('#pdfChk').checked;

    handleFile(files, outMode, wantPdf);
  });

  setStatus('Ready — upload JSON lalu klik Generate.');

})();
